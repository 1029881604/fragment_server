package team.antelope.fg.util.jdbc;

import java.io.IOException;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.Properties;

/*
 * 用到连接池的情况就是多线程，而每一个线程一般都只需要一个数据库连接，
 * 所以用ThreadLocal存储Connection没毛病
 */

/**
 * 数据库工具类
 * @author 华文财
 * @time:2017年11月11日 上午10:42:57
 * @Description:TODO
 */
public class DBUtil2 {
	static{
		Properties prop = new Properties();
		try {
			prop.load(Thread.currentThread().getContextClassLoader()
					.getResourceAsStream("config/jdbc/jdbc.properties"));
			String url = prop.getProperty("url");
			String username = prop.getProperty("username");
			String password = prop.getProperty("password");
			String driver = prop.getProperty("driver");
			int pool_max_size = Integer.parseInt(prop.getProperty("pool_max_size"));
			int pool_min_size = Integer.parseInt(prop.getProperty("pool_min_size"));
			ConnectionPool2.setUrl(url);
			ConnectionPool2.setUsername(username);
			ConnectionPool2.setPassword(password);
			ConnectionPool2.setDriver(driver);
			System.out.println("assdd"+pool_min_size);
			ConnectionPool2.setPool_max_size(pool_max_size);
			ConnectionPool2.setPool_min_size(pool_min_size);
		} catch (IOException e) {
			// TODO 自动生成的 catch 块
			e.printStackTrace();
			System.out.println("读取配置文件出错");
		} catch (NumberFormatException e){
			e.printStackTrace();
			System.out.println("数字转换出错");
			System.exit(0);
		}
		
	}
	private static ConnectionPool2 cp = ConnectionPool2.getInstance();
	private static ThreadLocal<Connection> threadLocal = new ThreadLocal<Connection> ();
//	/**
//	 * 获取数据库连接  没有用ThreadLocal之前
//	 * @return 
//	 * Connection
//	 */
//	public static Connection getConn(){
//		Connection conn = cp.getConn();
//		return conn;
//	}
	/**
	 * 获取数据库连接   用ThreadLocal之后  要用到连接只能是线程本地连接
	 * @return 
	 * Connection
	 */
	public static Connection getConn(){
		Connection conn = threadLocal.get();
		if(conn == null){
			conn = cp.getConn();
			threadLocal.set(conn);
		}
		return conn;
	}
	
	/*
	 * 获取PreparedStatement    
	 * Override
	 */
	public static PreparedStatement getStmt(Connection conn, String sql){
		PreparedStatement pstmt = null;
		if(conn != null){
			try {
				pstmt = conn.prepareStatement(sql);
			} catch (SQLException e) {
				// TODO 自动生成的 catch 块
				e.printStackTrace();
			}
		}
		return pstmt;
	}
	/*
	 * 获取PreparedStatement   自动生成的key  
	 * Override
	 */
	public static PreparedStatement getStmt(Connection conn, String sql, int autoGeneratedKey){
		PreparedStatement pstmt = null;
		if(conn != null){
			try {
				pstmt = conn.prepareStatement(sql, autoGeneratedKey);
			} catch (SQLException e) {
				// TODO 自动生成的 catch 块
				e.printStackTrace();
			}
		}
		return pstmt;
	}
	/* Override
	 */
	public static Statement getStmt(Connection conn){
		Statement stmt = null;
		if(conn != null){
			try {
				stmt = conn.createStatement();
			} catch (SQLException e) {
				// TODO 自动生成的 catch 块
				e.printStackTrace();
			}
		}
		return stmt;
	}
	/*
	 * 查询
	 */
	public static ResultSet exeQuery(PreparedStatement stmt){
		ResultSet rs = null;
		if(stmt != null){
			try {
				rs = stmt.executeQuery();
			} catch (SQLException e) {
				// TODO 自动生成的 catch 块
				e.printStackTrace();
			}
		}
		return rs;
	}
	/*
	 * 查询
	 */
	public static ResultSet exeQuery (Statement stmt, String sql){
		ResultSet rs = null;
		if(stmt != null){
			try {
				rs = stmt.executeQuery(sql);
			} catch (SQLException e) {
				// TODO 自动生成的 catch 块
				e.printStackTrace();
			}
		}
		return rs;
	}
	/*
	 * 万能查询,不用获取连接，不用获取语句，不用手动关闭   
	 */
	public static Object exeQuery (String sql,Object params[],IResultSetHandler rsh){
		Connection conn = null;
		PreparedStatement pstmt = null;
		ResultSet rs = null;
		try{
			conn = getConn();
			pstmt = conn.prepareStatement(sql);
			for(int i=0; i<params.length; i++){
				pstmt.setObject(i+1, params[i]);/*注意  i+1*/
			}
			rs = pstmt.executeQuery();
			
			return rsh.handler(rs);	//交给rsh处理
			
		} catch(SQLException e){
			e.printStackTrace();
		} finally{
			close(pstmt);  
			close();
		}
		return null;
	}
	
	public static int exeUpdate(PreparedStatement pstmt){
		int affectRow = 0;
		if(pstmt != null){
			try {
				affectRow = pstmt.executeUpdate();
			} catch (SQLException e) {
				// TODO 自动生成的 catch 块
				e.printStackTrace();
			}
		}
		return affectRow;
	}
	
//	/*
//	 * 关闭资源
//	 */
//	public static void close(Connection conn){
//		if(conn != null){
//			cp.close(conn);
//		}
//	}
	/*
	 *关闭连接不用传入conn了，要传入也只能传threadLocal的conn 
	 */
	public static void close(){
		Connection conn = threadLocal.get();
		if(conn != null){
			cp.close(conn);
			//解除当前线程上绑定conn
			threadLocal.remove();
		}
	}
	public static void close (Statement stmt){
		if(stmt != null){
			try {
				stmt.close();
				stmt = null;
			} catch (SQLException e) {
				// TODO 自动生成的 catch 块
				e.printStackTrace();
			}
		}
		
	}

	public static void close(ResultSet rs) {
		// TODO 自动生成的方法存根
		if(rs != null){
			try {
				rs.close();
				rs = null;
			} catch (SQLException e) {
				// TODO 自动生成的 catch 块
				e.printStackTrace();
			}
		}
	}
	
}
